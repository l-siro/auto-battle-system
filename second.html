<!DOCTYPE html>
<html>

<head>
  <title>Battle Simulator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #status,
    #log {
      border: 1px solid black;
      padding: 10px;
      margin-bottom: 10px;
      height: 300px;
      overflow-y: scroll;
    }

    #log .attack_A {
      color: blue;
    }

    #log .attack_B {
      color: red;
    }

    #log .miss_A,
    #log .miss_B {
      color: gray;
    }

    #log .result {
      font-weight: bold;
      color: green;
    }

    #characterList {
      margin-bottom: 10px;
    }

    #characterList .character {
      margin-bottom: 5px;
      padding: 5px;
      border: 1px solid black;
    }

    .character-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 1px solid black;
      padding: 10px;
      margin: 10px;
    }

    .character-img {
      width: 100px;
      height: 100px;
    }

    .character-name {
      font-size: 20px;
      margin: 10px 0;
    }

    .character-stats {
      margin: 10px 0;
    }
    @keyframes shake {
      0% { transform: translate(1px, 1px) rotate(0deg); }
      10% { transform: translate(-1px, -2px) rotate(-1deg); }
      20% { transform: translate(-3px, 0px) rotate(1deg); }
      30% { transform: translate(3px, 2px) rotate(0deg); }
      40% { transform: translate(1px, -1px) rotate(1deg); }
      50% { transform: translate(-1px, 2px) rotate(-1deg); }
      60% { transform: translate(-3px, 1px) rotate(0deg); }
      70% { transform: translate(3px, 1px) rotate(-1deg); }
      80% { transform: translate(-1px, -1px) rotate(1deg); }
      90% { transform: translate(1px, 2px) rotate(0deg); }
      100% { transform: translate(1px, -2px) rotate(-1deg); }
    }

    .character-card.shake {
      animation: shake 0.5s;
      animation-iteration-count: 1;
    }

    @keyframes flash {
      from {background-color: red;}
      to {background-color: inherit;}
    }

    .character-card.flash {
      animation: flash 1s;
      animation-iteration-count: 1;
    }

  </style>
</head>

<body>
  <h1>Battle Simulator</h1>

  <div id="characterList"></div>

  <form id="addCharacterForm">
    <input type="file" id="loadFile">

    <input type="text" id="name" placeholder="名前" required>
    <input type="number" id="attack" placeholder="攻撃力" min="1" required>
    <input type="number" id="defense" placeholder="防御力" min="0" required>
    <input type="number" id="hp" placeholder="HP" min="1" required>
    <input type="number" id="speed" placeholder="速力" min="0" required>
    <input type="number" id="accuracy" placeholder="命中力" min="0" max="1" step="0.1" required>
    <input type="number" id="evasion" placeholder="回避力" min="0" max="1" step="0.1" required>
    <input type="" id="role" placeholder="役職" required>
    <select id="role" required>
      <option value="">role</option>
      <option value="attacker">attacker</option>
      <option value="healer">healer</option>
      <option value="tank">tank</option>
    </select>
    <select id="team" required>
      <option value="">Team</option>
      <option value="A">A</option>
      <option value="B">B</option>
    </select>
    <input type="submit" value="Add Character">
  </form>

  <button id="startButton">Start Battle</button>

  <h2>TeamA</h2>
  <div id="statusA"></div>
  <h2>TeamB</h2>
  <div id="statusB"></div>
  <div id="log"></div>

  <script>
  let characters = [];

  const fileInput = document.getElementById('loadFile');
  fileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    const reader = new FileReader();

    reader.onload = (event) => {
      try {
        characters = JSON.parse(event.target.result);  // characters array is reset here
        createCharacterCards();
        document.getElementById("startButton").disabled = false;
      } catch (e) {
        console.error('The uploaded file is not valid JSON:', e);
      }
    };

    reader.readAsText(file);
  });

document.getElementById('addCharacterForm').addEventListener('submit', function (event) {
  event.preventDefault();
  let character = {
    name: event.target.name.value,
    attack: parseInt(event.target.attack.value, 10),
    defense: parseInt(event.target.defense.value, 10),
    hp: parseInt(event.target.hp.value, 10),
    maxHP: parseInt(event.target.maxHP.value, 10),
    speed: parseInt(event.target.speed.value, 10),
    accuracy: parseFloat(event.target.accuracy.value),
    evasion: parseFloat(event.target.evasion.value),
    team: event.target.team.value,
    role: event.target.role.value
  };

  // Add new character only if it doesn't exist already
  if (!characters.some(existingCharacter => existingCharacter.name === character.name)) {
    characters.push(character);
  }
  
  event.target.reset();
  updateCharacterList();
});

document.getElementById('startButton').addEventListener('click', function () {
  updateStatus();
  startBattle();
});




    function getActionOrder() {
      let actionOrder = [];
      // 最大速度を取得
      let maxSpeed = Math.max(...characters.map(c => c.speed));
      // 速度0から最大速度までループ
      for (let speed = maxSpeed; speed >= 0; speed--) {
        // 速度が同じキャラクターを取得
        let sameSpeedCharacters = characters.filter(c => c.speed === speed);
        // そのキャラクターをランダムに並べ替えて行動順序のリストに追加
        while (sameSpeedCharacters.length > 0) {
          let randomIndex = Math.floor(Math.random() * sameSpeedCharacters.length);
          actionOrder.push(sameSpeedCharacters[randomIndex]);
          sameSpeedCharacters.splice(randomIndex, 1);
        }
      }
      return actionOrder;
    }

    function updateStatus() {
      statusA.innerHTML = '';
      statusB.innerHTML = '';
      characters.forEach((character) => {
        let statusElement = document.createElement('p');
        statusElement.textContent = `${character.name}（${character.role ? character.role : "役職なし"}）: ${character.hp}/${character.maxHP}`;
        if (character.team === 'A') {
          statusA.appendChild(statusElement);
        } else {
          statusB.appendChild(statusElement);
        }
      });
    }

  document.getElementById('loadFile').addEventListener('change', function (e) {
    let file = e.target.files[0];
    if (!file) {
      return;
    }
    let reader = new FileReader();
    reader.onload = function (e) {
      let contents = e.target.result;
      let data = JSON.parse(contents);
      for (let character of data) {
        characters.push(character);
      }
      updateCharacterList();
    };
    reader.readAsText(file);
  });
  function updateCharacterList() {
    let characterList = document.getElementById("characterList");
    characterList.innerHTML = '';
    for (let character of characters) {
      let card = document.createElement("div");
      card.id = `character-${character.id}`;
      card.className = "character-card";

      let img = document.createElement("img");
      img.src = character.image ? character.image : `img/${character.role}.svg`;
      img.className = `character-img`;
      card.appendChild(img);

      let name = document.createElement("p");
      name.textContent = character.name;
      name.className = `character-name`;
      card.appendChild(name);

      let hp = document.createElement("p");
      hp.textContent = `HP: ${character.hp}/${character.maxHP}`;
      card.appendChild(hp);

      let role = document.createElement("p");
      role.textContent = `Role: ${character.role}`;
      card.appendChild(role);

      characterList.appendChild(card);
    }
  }



  function startBattle() {
    let turn = 0;

    // 行動順序のリストを生成
    let actionOrder = getActionOrder();

    function nextTurn() {
      if (characters.filter(c => c.team === 'A' && c.hp > 0).length > 0 &&
        characters.filter(c => c.team === 'B' && c.hp > 0).length > 0) {

        // 行動順序のリストに従ってキャラクターが行動
        let character = actionOrder[turn % actionOrder.length];

        if (character.hp <= 0) {
          // HPが0以下のキャラクターは行動しない
          turn++;
          setTimeout(nextTurn, 1000);
          return;
        }

        // ヒーラーの回復行動
        if (character.role === 'healer') {
          let allies = characters.filter(c => c.team === character.team && c.hp > 0 && c.hp < c.maxHP); // 死亡キャラクターを除外
          if (allies.length > 0 && Math.random() < 0.5) {
            let ally = allies[Math.floor(Math.random() * allies.length)];
            let heal = character.attack;
            ally.hp = Math.min(ally.hp + heal, ally.maxHP);
            addLog(`${character.name} → ${ally.name}  ${Math.floor(heal)}HP回復！`, "heal_" + character.team);
            turn++;
            // updateStatus(); 行動毎に更新しない
            setTimeout(nextTurn, 1000);
            return;
          }
        }

          let targets = characters.filter(c => c.team !== character.team && c.hp > 0);
          if (targets.length > 0) {
            let originalTarget = targets[Math.floor(Math.random() * targets.length)];
            let target = originalTarget;

            // タンクの防御行動をチェック
            if (target.role !== 'tank') {
              let tank = characters.find(c => c.team !== character.team && c.role === 'tank' && c.hp > 0);
              if (tank && Math.random() < 0.5) {
                target = tank;
                addLog(`${tank.name}が${originalTarget.name}を守った！`, "tank_" + tank.team);
              }
            }


            if (Math.random() < character.accuracy - target.evasion) {
              let damage = Math.max(0, Math.floor(character.attack - target.defense + character.attack * (Math.random() * 0.2 - 0.1)));
              if (Math.random() < character.accuracy / 10) {
                damage *= 2;
                addLog(`${character.name} ▶ ${target.name}  ${Math.floor(damage)}ダメージ（クリティカル）！`, "attack_" + character.team);
              } else {
                addLog(`${character.name} ▶ ${target.name}  ${Math.floor(damage)}ダメージ！`, "attack_" + character.team);
              }
              target.hp -= damage;
              if (target.hp <= 0) {
                target.hp = 0;
                addLog(`${target.name} が倒れた！`, "defeat_" + target.team);
              }
            } else {
              addLog(`${character.name} の攻撃が ${target.name} にミス！`, "miss_" + character.team);
            }
          }
          turn++;
          // 行動が終わったらステータスを更新
          updateStatus();
          setTimeout(nextTurn, 1000);
        } else {
          // 勝敗が決まった場合
          if (characters.filter(c => c.team === 'A' && c.hp > 0).length > 0) {
            addLog("チームAが勝利した！", "result");
          } else {
            addLog("チームBが勝利した！", "result");
          }
          battleInProgress = false;
          updateStatus(); // 戦闘が終わったらステータスを更新
        }
      }

      nextTurn();
    }


    function addLog(text, className) {
      let log = document.getElementById("log");
      let div = document.createElement("div");
      div.textContent = text;
      div.className = className;
      log.appendChild(div);
      log.scrollTop = log.scrollHeight;
    }
  </script>
</body>

</html>